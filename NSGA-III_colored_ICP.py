from data_preprocessing import prepare_dataset, assign_colors
from align_func import execute_global_registration, icp_registration, colored_icp
from GA import evaluation_colored_icp
from deap import algorithms, base, creator, tools

import open3d as o3d
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import glob 
import copy
import random
import os
import sys

################################ 1) Change variables here ################################ 

target_positions_dir = "/rds/user/kt427/hpc-work/zfin_mapping/target/xyz_target_notoprog_eye.xls"
target_color_dir = "./rds/user/kt427/hpc-work/zfin_mapping/target/sox2_target_notoprog_eye.xls"
source_positions_dir = "/rds/user/kt427/hpc-work/zfin_mapping/target/xyz_target_notoprog_eye.xls"
source_color_dir = "./rds/user/kt427/hpc-work/zfin_mapping/target/sox2_target_notoprog_eye.xls"

save_results_path = "/rds/user/kt427/hpc-work/zfin_mapping/optim_results"
result_name = "NSGA3_coloredICP_run"
n_runs = 20

################################ 2) Importing files and data preprocessing ###############################################

## Source ##
source_positions_names = glob.glob(source_positions_dir)
source_positions_excel = [pd.read_excel(file, skiprows = [0], header = 0, usecols = [0,1,2]) 
                  for file in source_positions_names]

source_color_names = glob.glob(source_color_dir)
source_color_excel = [pd.read_excel(file, skiprows = [0], header = 0, usecols = [0]) 
             for file in source_color_names]
## Target ## 
target_positions_names = glob.glob(target_positions_dir)
target_positions_excel = [pd.read_excel(file, skiprows = [0], header = 0, usecols = [0,1,2]) 
                  for file in target_positions_names]

target_color_names = glob.glob(target_color_dir)
target_color_excel = [pd.read_excel(file, skiprows = [0], header = 0, usecols = [0]) 
             for file in target_color_names]

positions_names_list = source_positions_names + target_positions_names 
positions_excel_list = source_positions_excel + target_positions_excel
color_excel_list = source_color_excel + target_color_excel
source_color =color_excel_list[0].to_numpy(dtype='float64')
target_color =color_excel_list[1].to_numpy(dtype='float64')

source, target, source_processed, target_processed, source_fpfh, target_fpfh = prepare_dataset(excel_list, names_list)

assign_colors(source,target,color_excel_list,"viridis")

######################### 3) DEAP code #################################

# results.fitness (MAX), results.inlier_mse (MIN), mae (MIN)
creator.create("FitnessMulti", base.Fitness, weights=(1.0, -1.0, -1.0)) 

# A list-type individual with a fitness attribute
creator.create("Individual", list, fitness=creator.FitnessMulti)

# Instantiate a Toolbox to register all the evolutionary operators.
toolbox = base.Toolbox()


NDIM = 10
NOBJ = 3
p = 12
toolbox.pop_size = 30
toolbox.max_gen = 500
CXPB = 1.0
MUTPB = 1.0
ref_points = tools.uniform_reference_points(NOBJ, p)


""" Registering operators""" 
toolbox.register("generator", generator)

# Structure initializers
# define 'individual' to be a single individual taking up the values generated by the toolbox.generator. So we don't 
# need to repeat the toolbox.generator function. 
# This gives us flexibilty to define each parameter with its unique distribution, instead of keeping the distribution
# the same and applying it repeatedly across each parameter.

toolbox.register("individual", tools.initIterate, creator.Individual, 
    toolbox.generator)

# define the population to be a list of individuals # We don't define n here, but in the main body to give flexibility to num individuals.
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

# Operator registration
#----------
# register the goal / fitness function
toolbox.register("evaluate", evaluation_colored_icp, filenames= filenames, target_color = sox2_target, source_color = sox2_source)

toolbox.register("results", colored_icp_results, filenames= filenames, target_color = sox2_target, source_color = sox2_source)

# register the crossover operator
toolbox.register("mate", tools.cxTwoPoint)

# register a mutation operator 

toolbox.register("mutate", mutation, indpb = [0.2]*NDIM)

toolbox.register("select", tools.selNSGA3, ref_points = ref_points )

""" Main body of DEAP"""

def main(iter_ = 0, run_name = "./test"):
    random.seed(iter_ )
    
    # Initialize statistics object
     ## Creating logbook for recording statistics
        
    stats_o3d_fitness = tools.Statistics(lambda ind: ind.fitness.values[0])
    stats_o3d_rmse = tools.Statistics(lambda ind: ind.fitness.values[1])
    stats_o3d_mae = tools.Statistics(lambda ind: ind.fitness.values[2])
    mstats = tools.MultiStatistics(o3d_fitness=stats_o3d_fitness, 
                                   o3d_rmse =stats_o3d_rmse,
                                   o3d_mae = stats_o3d_mae)
    
    mstats.register("mean", lambda ind: round(sum(ind)/len(pop),3))
    mstats.register("max", lambda ind: round(np.max(ind),3))
    mstats.register("min", lambda ind: round(np.min(ind),3))
    
    logbook = tools.Logbook()
    logbook.header = ["gen", "evals", "o3d_fitness", "o3d_rmse", "o3d_mae"]
    logbook.chapters["o3d_fitness"].header = ["mean", "max"]
    logbook.chapters["o3d_rmse"].header = ["mean", "min"]
    logbook.chapters["o3d_mae"].header = ["mean", "min"]
    
    pop = toolbox.population(n= toolbox.pop_size)
        
    # Evaluate the individuals with an invalid fitness
    invalid_ind = [ind for ind in pop if not ind.fitness.valid]
    fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
        
    for ind, fit in zip(invalid_ind, fitnesses):
        ind.fitness.values = fit[0:3]

    Compile statistics about the population
    record = mstats.compile(pop)
    logbook.record(gen=0, evals=len(invalid_ind), **record)
    print("Initial logbook.stream", logbook.stream)
    
    # Begin the generational process
    
    for gen in range(1, toolbox.max_gen):
        
        #Apply crossover and mutation to generate new offsprings. Return a list of varied individuals that are independent of their parents.
        offspring = algorithms.varAnd(pop, toolbox, CXPB, MUTPB)
        fitnesses_offspring = [ind.fitness for ind in offspring if ind.fitness.valid]

        # Evaluate the individuals with an invalid fitness
        invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
        
        fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
        
        for ind, fit in zip(invalid_ind, fitnesses):
            ind.fitness.values = fit[0:3]
            if fit[3].size: #If a correspondence map is present:
                corr_map_info = {"gen" : gen, "individual" : ind, "correspondence_set" : fit[3].tolist(), "fitness":ind.fitness.values[0],
                                 "inlier_rmse": ind.fitness.values[1], "mae": ind.fitness.values[2]}
                corr_map_results.append(corr_map_info)
                
        # Select the next generation population from parents and offspring
        pop = toolbox.select(pop + offspring, toolbox.pop_size)
      
        # Compile statistics about the new population
        record = mstats.compile(pop)
        logbook.record(gen=gen, evals=len(pop), **record)
        print(f"{gen} Statistics of next population: {logbook.stream}")

    print(f"--End of (successful) evolution --")
    
    corr_map_results_df = pd.DataFrame(corr_map_results)
    
    ## Saving best individuals and logbook
    newpath = run_name

    if not os.path.exists(newpath):
        os.makedirs(newpath)
    
    corr_map_results_df.to_csv(f'{newpath}/corrmapresults_coloredICP_run{iter_}.csv', index=False)
    
    results = {"gen" : logbook.select("gen"),
                "eval" : logbook.select("evals"),
                "o3d_fitness_mean" : logbook.chapters['o3d_fitness'].select("mean"),
                "o3d_fitness_max" : logbook.chapters['o3d_fitness'].select("max"),
                "o3d_rmse_mean" : logbook.chapters['o3d_rmse'].select("mean"),
                "o3d_rmse_min" : logbook.chapters['o3d_rmse'].select("min"),
                "o3d_mae_mean" : logbook.chapters['o3d_mae'].select("mean"),
                "o3d_mae_min" : logbook.chapters['o3d_mae'].select("min")}
    
    df_log = pd.DataFrame.from_dict(results) 
    df_log.to_csv(f'{newpath}/logbook_run{iter_}.csv', index=False) # Writing to a CSV file
    
merged_path_name = os.path.join(hpc_rds_path, image_name, result_name)

######################### 4) Running the genetic algorithm #################################

for i in range(n_runs):
    run_name = f'{merged_path_name}{i}'
    main(iter_ = i, run_name = run_name)
    